\section{Детали реализации}
В этой главе будут описаны основные инструменты, использованные при создании приложения, а также выделены основные особенности 
архитектуры приложения.

\subsection{Инструменты}
Приложение реализовано на языке Си. Самая известная библиотека для создания пользовательского интерфейса на этом языке --- GTK. 
А именно, была выбрана третья версия этой библиотеки --- GTK3\cite{gtk3}, предоставляющая множество примитивов для построения 
пользовательского интерфейса. Это не последняя стабильная версия библиотеки, так как с начала 2021 года стала доступна версия GTK4. 
Однако основные библиотеки, которые используются вместе с GTK пока не совместимы с новой версией, поэтому работа велась с версией GTK3, 
которая продолжает поддерживаться.

Помимо пользовательского интерфейса приложение состоит также из вычислительной части, отвечающей за применение фильтров к изображениям. 
Вычисления производятся как на центральном процессоре, так и на видеокарте.

Для распараллеливания вычислений на процессоре используется OpenMP\cite{openmp} - стандарт для распараллеливания программ на языке С, 
С++, Fortran. ОpenMP предоставляет реализацию многопоточных параллельных вычислений, доступ к которым происходит через директивы компилятора.

На видеокарте вычисления реализованы с помощью библиотеки OpenCL\cite{opencl}, которая позволяет исполнять программы на графическом 
процессоре, обеспечивая при этом параллелизм на уровне данных.

\subsection{Особенности архитектуры}
Архитектуру приложения можно разделить на две части: интерфейс и вычислительную часть приложения.

\subsubsection{Интерфейс}
Интерфейс приложения представляет собой одно окно, которое наполнено различными компонентами. Их инициализация происходит после того, 
как пользователь выберет изображение для просмотра. Компоненты помещаются в Gtk grid, который отвечает за их расположение относительно 
друг друга внутри окна. При этом каждый компонент занимается отдельной функцией приложения.

Так, например, панель с фильтрами (filterspanel) служит пользователю инструментом выбора и задания фильтров, контейнер изображения 
(imagebox) ответственен за показ изображения и выравнивание его внутри окна с сохранением пропорций изначальной картинки, контейнер 
для информации об изображении (listbox) хранит в себе информацию о картинке и представляет размер и другие характеристики изображения 
в удобном формате.

Таким образом, для добавления новых функциональных частей в интерфейс достаточно создать новый компонент и разместить его в Gtk grid 
относительно других компонентов.

Интерфейс взаимодействует с вычислительной частью приложения через функции, которые предоставляет ему файл \textit{filters.c}. 
А именно, пользуется вызовом двух функций \textit{apply\_filters\_service()} и \textit{apply\_and\_save\_filters\_service()}, 
в которые подаются данные изображения и фильтра, который будет применен. Данные о фильтре, такие как ядро фильтра, размер ядра 
и веса коррекции фильтра собирает панель с фильтрами и отправляет одним из параметров в выше перечисленные функции. Получается, 
что общение происходит только между основным компонентом интерфейса --- filterspanel и доступными функциями файла \textit{filters.c}. 
При расширении функций приложения подразумевается, что будут вызываться именно эти функции, а не напрямую реализации алгоритмов применения фильтра.

\subsubsection{Вычислительная часть}
Вычислительная часть приложения реализует один и тот же алгоритм наложения матричного фильтра\cite{filter}, используя разные 
вычислительные устройства.

Фильтр задается ядром, которое представляет собой квадратную матрицу нечетной размерности, сумма элементов которой чаще всего равна 
единице, что позволяет сохранить яркость изначального изображения. Само вычисление фильтра представляет собой итерацию через два вложенных 
двойных цикла, которые, проходя через каждый пиксель изображения и через каждый элемент ядра матрицы, выбирают квадратную подматрицу 
с размерностью ядра в изображении, накладывают центр ядра на текущий пиксель и получают новую матрицу поэлементным умножением. Сумма 
элементов полученной матрицы записывается в пиксель нового изображения. Пиксели находящиеся за пределами изображения оборачиваются вокруг.

Сам алгоритм представлен в виде псевдокода в листинге \ref{algo}.

Было реализовано три версии алгоритма наложения матричного фильтра: на процессоре (CPU), на процессоре с применением параллельных 
вычислений (CPU parallel) и на видеокарте (GPU). Реализация на процессоре с применением параллельных вычислений использует директиву 
компилятора (\verb!# pragma omp parallel for!) для распараллеливания внешнего двойного цикла, что позволяет задействовать все ядра процессора. 
Реализация на GPU основана на использовании библиотеки OpenCL. Для этого написана программа, работающая на процессоре (хосте), 
которая компилирует код исполняемый на видеокарте, а также пересылает данные из оперативной памяти в видеопамять и обратно, контролируя 
процесс исполнения программы на графическом устройстве. Таким образом, GPU-алгоритм использует большое количество ядер видеокарты для 
ускорения вычислений, но в обмен возникают затраты на выполнение некоторых подготовительных операции на процессоре.

Все алгоритмы реализованы в отдельном файле и отделены от логики интерфейса приложения. Для того, чтобы расширить вычисления новым 
алгоритмом, достаточно написать аналогичную реализацию и поместить в файл с другими алгоритмами. После чего новый алгоритм можно будет 
вызвать из одной из функций, которые отвечают за взаимодействие с интерфейсом.


\begin{minipage}{0.95\textwidth}
\begin{algorithm}[H]
    \centering
    \caption{Наложение матричного фильтра (псевдокод)}\label{algo}
    \begin{verbatim}
    # Input: image - image pixel buffer,
             filter data - kernel (k) and biases (f, b)
    # Output: result - result image pixel buffer
    
    # Get image properties such as:
    # - channels
    # - width
    # - height
    
    FOR x TO width
    FOR y TO height
    # multiply every value of the filter with corresponding image pixel
        FOR filterY TO filterHeight
        FOR filterX TO filterWidth
            imageX = (x - filterWidth / 2 + filterX + width) % width
            imageY = (y - filterHeight / 2 + filterY + height) % height
            FOREACH channel IN channels
                channel = image[y*width+x].channel * k[filterX][filterY]
    # truncate values smaller than zero and larger than 255
        FOREACH channel IN channels
            result[y*width+x].channel = MIN(MAX((f*channel+b), 0), 255)
    \end{verbatim}
\end{algorithm}
\end{minipage}\hfill

\pagebreak